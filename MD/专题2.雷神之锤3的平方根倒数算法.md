最近又刷到雷神之锤3的快速求平方根倒数算法，专门来记一记
不一定完整，有机会的话再补充 

首先贴代码  
``` c
float Q_rsqrt(float number)
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y = number;
    i = *(long *)&y;
    i = 0x5f3759df - (i >> 1);
    y = *(float *)&i;
    y = y * (threehalfs - (x2 * y * y));

    return y;
}
```

首先说一下16行代码是怎么来的，这个是使用的牛顿迭代法  
牛顿迭代法：  
```
    在x=x0处二阶泰勒展开  
    f(x)=f(x0)+f'(x0)(x-x0)  
    忽略后面的二次项，令f(x)=0等式变形得：  
    x=xn-f(xn)/f'(xn)  
```
    几何意义：
    过一点(x0,f(x0))作切线，求其与x轴的交点，
    然后不断重复，这个交点就会不断逼近函数与x轴交点。
    那么递推公式是x(n+1)=xn-f(xn)/f'(xn)
    
    这样就能理解以下几点：
    1、 对初值选取要求较高，在初值x0离方程的根很近的时候
        递推的次数就会很少。
    2、 如果方程有多个根，根据初值x0选取的不同可能会收敛
        于不同的根。
    
    我们要求的是1/√m，即求x=1/√m的根
    这个算法中是这么转化的：
    f(x)=1/x² - m = 0
    f'(x)=-2/x³，代入递推公式得到
    x(n+1)=xn(3/2 + n*x²/2)，即第十六行表示
    正常使用方法是不断递归，直到x(n+1)-xn < 精度要求

该算法的重点是怎么找的x0初值，让一次迭代就能很逼近实际值  
雷神之锤3要求的精度是小数点后三位，该方法满足要求  
    首先是32位浮点数包括有：  
    1位符号位、8位指数位、23位尾数位  
    记浮点数x其对应的二进制b表示(除去最高符号位)，其指数位E、尾数M  
    例：十进制小数6.36用二进制表示为：  
        0 10000001 10010111000010100011111  
    则  b=(10000001 10010111000010100011111)B  
        E=(10000001)B  
        M=(10010111000010100011111)B  
    有等式  ①：b=E*2^23+M   
            ②：x=(1+M/2^23)*2^(E-127)  
    等式②左右两端取对数  
        log2(x)=log2( (1+M/2^23) * 2^(E-127) )  
            =log2( 1+M/2^23 ) + E-127  
            ≈M/2^23 + μ + E -127  
            =1/2^23 * (M + 2^23 * E) + μ -127  
            =1/2^23 * b + μ -127  
    则，浮点数的二进制表示b可以用来表示浮点数x的对数log2(x)  
    在x=1/√m左右两边同时取对数  
    log2(x) = -1/2 * log2(a)  
    1/2^23 * bx + μ -127 = -1/2 * (1/2^23 * bm + μ -127)  
    bx=3 * 2^22 * (127-μ) - 1/2 * bm  
    这个就是14行神秘数字0x5f3759df的来源，其中由于有一个近似值μ，所以也只是一个近似值，需要在附近找找有没有更合适的值
